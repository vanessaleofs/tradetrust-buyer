"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ethers_1 = require("ethers");
var __1 = require("../..");
var contractNotFound = function (address) {
    return {
        code: __1.OpenAttestationEthereumDocumentStoreIssuedCode.CONTRACT_NOT_FOUND,
        codeString: __1.OpenAttestationEthereumDocumentStoreIssuedCode[__1.OpenAttestationEthereumDocumentStoreIssuedCode.CONTRACT_NOT_FOUND],
        message: "Contract " + address + " was not found"
    };
};
var contractAddressInvalid = function (address) {
    return {
        code: __1.OpenAttestationEthereumDocumentStoreIssuedCode.CONTRACT_ADDRESS_INVALID,
        codeString: __1.OpenAttestationEthereumDocumentStoreIssuedCode[__1.OpenAttestationEthereumDocumentStoreIssuedCode.CONTRACT_ADDRESS_INVALID],
        message: "Contract address " + address + " is invalid"
    };
};
exports.contractNotIssued = function (merkleRoot, address) {
    return {
        code: __1.OpenAttestationEthereumDocumentStoreIssuedCode.DOCUMENT_NOT_ISSUED,
        codeString: __1.OpenAttestationEthereumDocumentStoreIssuedCode[__1.OpenAttestationEthereumDocumentStoreIssuedCode.DOCUMENT_NOT_ISSUED],
        message: "Certificate " + merkleRoot + " has not been issued under contract " + address
    };
};
exports.contractRevoked = function (merkleRoot, address) {
    return {
        code: __1.OpenAttestationEthereumDocumentStoreRevokedCode.DOCUMENT_REVOKED,
        codeString: __1.OpenAttestationEthereumDocumentStoreRevokedCode[__1.OpenAttestationEthereumDocumentStoreRevokedCode.DOCUMENT_REVOKED],
        message: "Certificate " + merkleRoot + " has been revoked under contract " + address
    };
};
exports.getErrorReason = function (error, address) {
    var _a;
    var reason = error.reason && Array.isArray(error.reason) ? error.reason[0] : (_a = error.reason, (_a !== null && _a !== void 0 ? _a : ""));
    if (reason.toLowerCase() === "contract not deployed".toLowerCase() && error.code === ethers_1.errors.UNSUPPORTED_OPERATION) {
        return contractNotFound(address);
    }
    else if ((reason.toLowerCase() === "ENS name not configured".toLowerCase() && error.code === ethers_1.errors.UNSUPPORTED_OPERATION) ||
        (reason.toLowerCase() === "bad address checksum".toLowerCase() && error.code === ethers_1.errors.INVALID_ARGUMENT) ||
        (reason.toLowerCase() === "invalid address".toLowerCase() && error.code === ethers_1.errors.INVALID_ARGUMENT)) {
        return contractAddressInvalid(address);
    }
    return {
        message: "Error with smart contract " + address + ": " + error.reason,
        code: __1.OpenAttestationEthereumDocumentStoreIssuedCode.ETHERS_UNHANDLED_ERROR,
        codeString: __1.OpenAttestationEthereumDocumentStoreIssuedCode[__1.OpenAttestationEthereumDocumentStoreIssuedCode.ETHERS_UNHANDLED_ERROR]
    };
};
