"use strict";

var _ = require(".");

var _sample = _interopRequireDefault(require("../test/fixture/sample.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const base64Regex = /^(?:[a-zA-Z0-9+/]{4})*(?:|(?:[a-zA-Z0-9+/]{3}=)|(?:[a-zA-Z0-9+/]{2}==)|(?:[a-zA-Z0-9+/]{1}===))$/;
const encryptionKeyRegex = new RegExp(`^[0-9a-f]{${_.ENCRYPTION_PARAMETERS.keyLength / 4}}$`);
describe("storage/crypto", () => {
  it("should encrypt and decrypt unicode symbols correctly", () => {
    const originalObject = JSON.stringify({
      data: "Rating(тЙд 25kg)"
    });
    const enc = (0, _.encryptString)(originalObject);
    const dec = (0, _.decryptString)(enc);
    expect(dec).toStrictEqual(originalObject);
  });
  it("should encrypt and decrypt larger documents", () => {
    const originalObject = JSON.stringify(_sample.default);
    const enc = (0, _.encryptString)(originalObject);
    const dec = (0, _.decryptString)(enc);
    expect(dec).toStrictEqual(originalObject);
  });
  describe("encryptString", () => {
    let encryptionResults;
    test("should have the right keys and values when no key passed",
    /*#__PURE__*/
    _asyncToGenerator(function* () {
      encryptionResults = (0, _.encryptString)("hello world");
      expect(encryptionResults).toStrictEqual(expect.objectContaining({
        cipherText: expect.stringMatching(base64Regex),
        iv: expect.stringMatching(base64Regex),
        tag: expect.stringMatching(base64Regex),
        key: expect.stringMatching(encryptionKeyRegex),
        type: _.ENCRYPTION_PARAMETERS.version
      }));
    }));
    test("should have the right keys and values when key is passed",
    /*#__PURE__*/
    _asyncToGenerator(function* () {
      const encryptionKey = "35fb46ca758889669f38c83d2f159b0f5a320b5a97387a9eaecb5652d15e0e3d";
      encryptionResults = (0, _.encryptString)("hello world", encryptionKey);
      expect(encryptionResults).toStrictEqual(expect.objectContaining({
        cipherText: expect.stringMatching(base64Regex),
        iv: expect.stringMatching(base64Regex),
        tag: expect.stringMatching(base64Regex),
        key: expect.stringMatching(encryptionKeyRegex),
        type: _.ENCRYPTION_PARAMETERS.version
      }));
      expect(encryptionResults.key).toStrictEqual(encryptionKey);
    }));
    test("should throw error if input is not a string", () => {
      encryptionResults = (0, _.encryptString)("hello world"); // @ts-ignore because we're explicitly testing failure mode

      expect(() => (0, _.encryptString)({})).toThrow("encryptString only accepts strings"); // @ts-ignore because we're explicitly testing failure mode

      expect(() => (0, _.encryptString)(2)).toThrow("encryptString only accepts strings");
    });
  });
  describe("decryptString", () => {
    test("can decrypt", () => {
      const encryptionResults = (0, _.encryptString)("hello world");
      expect((0, _.decryptString)(encryptionResults)).toBe("hello world");
    });
    test("can decrypt when encryption key is passed", () => {
      const encryptionKey = "35fb46ca758889669f38c83d2f159b0f5a320b5a97387a9eaecb5652d15e0e3d";
      const encryptionResults = (0, _.encryptString)("hello world", encryptionKey);
      expect((0, _.decryptString)(encryptionResults)).toBe("hello world");
    });
  });
  describe("encodeDocument & decodeDocument", () => {
    it("should do the reverse of each other", () => {
      const input = "hello";
      const encoded = (0, _.encodeDocument)(input);
      const decoded = (0, _.decodeDocument)(encoded);
      expect(decoded).toBe(input);
    });
    it("should work for unicode text", () => {
      const input = "ЁЯжДЁЯШ▒|certificate|шпБф╣ж|sijil|рдкреНрд░рдорд╛рдгрдкрддреНрд░";
      const encoded = (0, _.encodeDocument)(input);
      const decoded = (0, _.decodeDocument)(encoded);
      expect(decoded).toBe(input);
    });
    it("encodeDocument should return url safe characters only", () => {
      const input = "ЁЯжДЁЯШ▒|certificate|шпБф╣ж|sijil|рдкреНрд░рдорд╛рдгрдкрддреНрд░";
      const encoded = (0, _.encodeDocument)(input);
      expect(encodeURI(encoded)).toBe(encoded);
    });
  });
});