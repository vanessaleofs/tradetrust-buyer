import { last } from './helper';
import { parser } from './parser';
import { isCloseTag, isComment, isOpenCloseTag, isOpenTag, isSelfClosingTag, } from './regexp';
var Traverse = /** @class */ (function () {
    function Traverse(_a) {
        var code = _a.code, enter = _a.enter;
        this.code = code;
        this._enter = enter;
    }
    Traverse.prototype.combineLeftJsxNodes = function (jsxNodes) {
        var start = jsxNodes[0].position.start;
        var end = last(jsxNodes).position.end;
        return {
            type: 'jsx',
            data: jsxNodes[0].data,
            value: this.code.slice(start.offset, end.offset),
            position: {
                start: jsxNodes[0].position.start,
                end: last(jsxNodes).position.end,
            },
        };
    };
    // fix #7
    Traverse.prototype.combineJsxNodes = function (nodes, parent) {
        var _this = this;
        var offset = 0;
        var jsxNodes = [];
        var length = nodes.length;
        // eslint-disable-next-line sonarjs/cognitive-complexity
        return nodes.reduce(function (acc, node, index) {
            if (node.type === 'jsx') {
                var value = node.value;
                if (isOpenTag(value)) {
                    offset++;
                    jsxNodes.push(node);
                }
                else {
                    if (isCloseTag(value)) {
                        offset--;
                        jsxNodes.push(node);
                    }
                    // prettier-ignore
                    /* istanbul ignore next */
                    else if (!isComment(value) &&
                        !isSelfClosingTag(value) &&
                        !isOpenCloseTag(value)) {
                        try {
                            // fix #138
                            var nodes_1 = parser.normalizeJsxNode(node, parent);
                            jsxNodes.push.apply(jsxNodes, (Array.isArray(nodes_1) ? nodes_1 : [nodes_1]));
                        }
                        catch (_a) {
                            // should never happen, just for robustness
                            var start = node.position.start;
                            throw Object.assign(new SyntaxError('unknown jsx node: ' + JSON.stringify(value)), {
                                lineNumber: start.line,
                                column: start.column,
                                index: start.offset,
                            });
                        }
                    }
                    else {
                        jsxNodes.push(node);
                    }
                    if (!offset) {
                        // fix #158
                        var firstOpenTagIndex = jsxNodes.findIndex(function (node) {
                            return isOpenTag(node.value);
                        });
                        if (firstOpenTagIndex === -1) {
                            acc.push.apply(acc, jsxNodes);
                        }
                        else {
                            acc.push.apply(acc, jsxNodes.slice(0, firstOpenTagIndex));
                            acc.push(_this.combineLeftJsxNodes(jsxNodes.slice(firstOpenTagIndex)));
                        }
                        jsxNodes.length = 0;
                    }
                }
            }
            else if (offset) {
                jsxNodes.push(node);
            }
            else {
                acc.push(node);
            }
            if (index === length - 1 && jsxNodes.length > 0) {
                acc.push(_this.combineLeftJsxNodes(jsxNodes));
            }
            return acc;
        }, []);
    };
    Traverse.prototype.traverse = function (node, parent) {
        var _this = this;
        /* istanbul ignore if */
        if (!node) {
            // should never happen, just for robustness
            return;
        }
        var children = node.children;
        if (children) {
            var parent_1 = node;
            children = node.children = this.combineJsxNodes(children, parent_1);
            children.forEach(function (child) { return _this.traverse(child, parent_1); });
        }
        this._enter(node, parent);
    };
    return Traverse;
}());
export { Traverse };
export var traverse = function (root, options) {
    return new Traverse(options).traverse(root);
};
//# sourceMappingURL=traverse.js.map