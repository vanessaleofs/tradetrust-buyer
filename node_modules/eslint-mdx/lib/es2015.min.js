import{parse as e}from"espree";import t from"path";import s from"remark-mdx";import n from"remark-parse";import r from"unified";const o=["@typescript-eslint/parser","babel-eslint"],i=["JSXElement","JSXFragment"],a=e=>i.includes(e.type),c=t=>{if(t){if("string"==typeof t&&(t=require(t)),"object"==typeof t&&(t="parseForESLint"in t&&t.parseForESLint||"parse"in t&&t.parse),"function"!=typeof t)throw new TypeError("Invalid custom parser for `eslint-mdx`: "+t);return[t]}const s=[e];for(const e of o)try{const t=require(e),n="parseForESLint"in t?t.parseForESLint:t.parse;n&&s.unshift(n)}catch(e){}return s},l=e=>{const t=e.start.offset,s=e.end.offset;return{range:[t,s],loc:Object.assign({},e),start:t,end:s}};function p(e,t,s){if(!e||!e.loc||!e.range)return e;Object.entries(e).forEach(([n,r])=>{r&&(Array.isArray(r)?e[n]=r.map(e=>p(e,t,s)):e[n]=p(r,t,s))});const{loc:{start:n,end:r},range:o}=e,i=o[0]+s,a=o[1]+s;return Object.assign(Object.assign({},e),{start:i,end:a,range:[i,a],loc:{start:{line:t+n.line,column:n.column},end:{line:t+r.line,column:r.column}}})}const u=e=>e&&e[0],h=e=>e&&e[e.length-1],m=(e,t)=>t.every(t=>t in e),f="(?:\\s+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:\\s*=\\s*"+("(?:[^\"'=<>`\\u0000-\\u0020]+|'[^']*'|\"[^\"]*\"|"+"{.*}".replace(".","[\0-ï¿¿]")+")")+")?)",d="<[A-Za-z]*[A-Za-z0-9\\.\\-]*"+f+"*\\s*>",x="<\\s*\\/[A-Za-z]*[A-Za-z0-9\\.\\-]*\\s*>",g="<[A-Za-z]*[A-Za-z0-9\\.\\-]*"+f+"*\\s*\\/?>",y="\x3c!----\x3e|\x3c!--(?:-?[^>-])(?:-?[^-])*--\x3e",b="(\x3c!---*)",_="(-*--\x3e)",E=new RegExp(`^(?:${d})$`),j=new RegExp(`^(?:${x})$`),S=new RegExp(`^(?:${d+"[\\s\\S]*"+x})$`),w=new RegExp(`^(?:${g})$`),v=new RegExp(`^(?:${y})$`),J=new RegExp("(\x3c!---*)([\\s\\S]*?)(-*--\x3e)","g"),N=e=>E.test(e),$=e=>j.test(e),A=e=>v.test(e),L=e=>S.test(e),z=e=>w.test(e);class T{constructor({code:e,enter:t}){this.code=e,this._enter=t}combineLeftJsxNodes(e){const t=e[0].position.start,s=h(e).position.end;return{type:"jsx",data:e[0].data,value:this.code.slice(t.offset,s.offset),position:{start:e[0].position.start,end:h(e).position.end}}}combineJsxNodes(e,t){let s=0;const n=[],{length:r}=e;return e.reduce((e,o,i)=>{if("jsx"===o.type){const r=o.value;if(N(r))s++,n.push(o);else{if($(r))s--,n.push(o);else if(A(r)||z(r)||L(r))n.push(o);else try{const e=W.normalizeJsxNode(o,t);n.push(...Array.isArray(e)?e:[e])}catch(e){const{start:t}=o.position;throw Object.assign(new SyntaxError("unknown jsx node: "+JSON.stringify(r)),{lineNumber:t.line,column:t.column,index:t.offset})}if(!s){const t=n.findIndex(e=>N(e.value));-1===t?e.push(...n):(e.push(...n.slice(0,t)),e.push(this.combineLeftJsxNodes(n.slice(t)))),n.length=0}}}else s?n.push(o):e.push(o);return i===r-1&&n.length>0&&e.push(this.combineLeftJsxNodes(n)),e},[])}traverse(e,t){if(!e)return;let s=e.children;if(s){const t=e;s=e.children=this.combineJsxNodes(s,t),s.forEach(e=>this.traverse(e,t))}this._enter(e,t)}}const F=(e,t)=>new T(t).traverse(e),O=r().use(n).use(s).freeze(),k=["body","comments","tokens"],P=["export","import","jsx"],Z=["column","lineNumber"],R=[".mdx"],X=[".md"],C={comment:!0,ecmaFeatures:{jsx:!0},ecmaVersion:(new Date).getUTCFullYear(),sourceType:"module",tokens:!0,filePath:"__placeholder__.mdx",loc:!0,range:!0},H="<$>".length;class M{constructor(){this._options=C,this.parse=this.parse.bind(this),this.parseForESLint=this.parseForESLint.bind(this)}normalizeJsxNode(e,t,s=this._options){const n=e.value;if("jsx"!==e.type||A(n))return e;if(J.exec(n)){const s=[],{position:{start:{line:r,column:o,offset:i}}}=e;Object.assign(e,{data:Object.assign(Object.assign({},e.data),{jsxType:"JSXElementWithHTMLComments",comments:s,inline:!!t&&"root"!==t.type}),value:n.replace(J,(e,t,a,c,l)=>{const p=l+e.length,u=n.slice(0,l).split("\n"),m=n.slice(0,p).split("\n"),f=`{/${"*".repeat(t.length-2)}${a}${"*".repeat(c.length-2)}/}`,d=u.length-1,x=m.length-1;return s.push({fixed:f,loc:{start:{line:r+d,column:h(u).length+(d?0:o-1),offset:i+l},end:{line:r+x,column:h(m).length+(x?0:o-1),offset:i+p}},origin:e}),f})})}return this._normalizeJsxNodes(e,s)}parse(e,t){return this.parseForESLint(e,t).ast}parseForESLint(e,s){const n=t.extname(s.filePath),r=R.concat(s.extensions||[]).includes(n),o=X.concat(s.markdownExtensions||[]).includes(n);if(!r&&!o)return this._eslintParse(e,s);const i=O.parse(e);return this._ast=Object.assign(Object.assign({},l(i.position)),{type:"Program",sourceType:s.sourceType||"module",body:[],comments:[],tokens:[]}),this._services={JSXElementsWithHTMLComments:[]},r&&F(i,{code:e,enter:(e,t)=>{if(!P.includes(e.type))return;let n=this.normalizeJsxNode(e,t,s);n=Array.isArray(n)?n:[n],n.forEach(e=>this._nodeToAst(e,s))}}),{ast:this._ast,services:this._services}}_eslintParse(e,t){let s,n;this._parsers&&t.parser===this._options.parser||(this._parsers=c(t.parser)),t.filePath&&this._options!==t&&Object.assign(this._options,t);for(const t of this._parsers)try{s=t(e,this._options);break}catch(e){n||(n=e)}if(!s&&n)throw n;return"ast"in s&&s.ast?s:{ast:s}}_normalizeJsxNodes(e,t){const s=e.value;let n;try{n=this._eslintParse(`<$>${s}</$>`,t).ast}catch(t){if(m(t,Z)){const{position:{start:s}}=e;throw"index"in t?t.index+=s.offset-H:"pos"in t&&(t.pos+=s.offset-H),t.column=t.lineNumber>1?t.column:t.column+s.column-H,t.lineNumber+=s.line-1,t}return e}const{expression:r}=n.body[0];if(!a(r)||r.children.length<=1)return e;const{position:{start:{line:o,offset:i}}}=e;return r.children.reduce((t,n)=>{if(!a(n))return t;const{start:r,end:c,loc:{start:l,end:p}={start:{column:r,line:1},end:{column:c,line:1}},range:u=[r,c]}=n,h=o+l.line-1,m=o+p.line-1,f=u[0]-H,d=u[1]-H;return t.push({type:"jsx",data:t.length>0?null:e.data,value:s.slice(f,d),position:{start:{line:h,column:o===h?l.column-H:l.column,offset:i+f},end:{line:m,column:o===h?p.column-H:p.column,offset:i+d}}}),t},[])}_nodeToAst(e,t){e.data&&"JSXElementWithHTMLComments"===e.data.jsxType&&this._services.JSXElementsWithHTMLComments.push(e);const s=e.value;if(A(s))return;const{loc:n,start:r}=l(e.position),o=n.start.line-1;let i;try{i=this._eslintParse(s,t).ast}catch(e){throw m(e,Z)&&(e.index+=r,e.column=e.lineNumber>1?e.column:e.column+n.start.column,e.lineNumber+=o),e}const a=r-i.range[0];k.forEach(e=>this._ast[e].push(...i[e].map(e=>p(e,o,a))))}}const W=new M,{parse:q,parseForESLint:I}=W;export{k as AST_PROPS,j as CLOSE_TAG_REGEX,J as COMMENT_CONTENT_REGEX,v as COMMENT_REGEX,R as DEFAULT_EXTENSIONS,C as DEFAULT_PARSER_OPTIONS,P as ES_NODE_TYPES,o as FALLBACK_PARSERS,i as JSX_TYPES,Z as LOC_ERROR_PROPERTIES,X as MARKDOWN_EXTENSIONS,S as OPEN_CLOSE_TAG_REGEX,E as OPEN_TAG_REGEX,M as Parser,w as SELF_CLOSING_TAG_REGEX,T as Traverse,x as closeTag,y as comment,_ as commentClose,b as commentOpen,u as first,m as hasProperties,$ as isCloseTag,A as isComment,a as isJsxNode,L as isOpenCloseTag,N as isOpenTag,z as isSelfClosingTag,h as last,O as mdxProcessor,c as normalizeParser,l as normalizePosition,d as openTag,q as parse,I as parseForESLint,W as parser,p as restoreNodeLocation,g as selfClosingTag,F as traverse};
